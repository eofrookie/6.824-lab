1. 为什么切换环境前后对环境数据结构e都能解应用？（为什么还能正常识别它的地址）
答：env_setup_vm中设置了内核的页目录，所以所有环境内核部分对应的地址装换是一致的。
2. 切换环境什么时候保存上个环境的数据结构？
答：trap.c中curenv->env_tf = *tf;
3. dumbfork()的运行过程？
父进程调用sys_exofork()创建子进程，将父进程的环境复制给子进程，只是子进程的状态被设置为
not_runable,返回子进程的环境id，在把自己的地址空间和用户栈也复制给子进程，再将子进程的状态
设置为可运行的状态，父进程通过sys_yield（）启动子进程的运行，子进程运行过程与父进程一样，
不同的地方在于子进程调用sys_exofork()时需要返回0，从而不用进行到复制地址的代码，否则会报错。
所以在sys_exofork()调用中复制寄存器的内容时，要将eax寄存器的内容设置为0，调用env_pop_tf()
将环境寄存器的内容弹到对应的寄存器时保证子进程的%eax寄存器为0。
4. 写时复制
答：fork时将父进程的整个地址空间复制到子进程的代价过大，所以使用共享地址空间的方法，可以将地址空间
设置为只读属性，只有检测到需要修改地址页内容时才需要创建了一个新的、私有的、可写的页面副本。需要一个
可以处理用户级别页面错误的系统调用，用于检测。
5. popal自动复原常规寄存器，popfl恢复eflags寄存器，但是后面不可以使用subl等命令，会改变eflags寄存器的值
ret指令返回并将栈顶的内容pop给eip寄存器，也就是使得控制流接下来从栈顶的内容的地址开始执行
所以需要将之前的保存的trap time state eip寄存器推到trap time state esp上面，再执行ret指令
通过sys_env_set_pgfault_upcall()可以设置当前环境的页面错误处理要调用的函数，第一次时需要分配一页错误栈，
主要难点是寄存器、栈的保存与恢复，以及控制流的转移